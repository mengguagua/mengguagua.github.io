{"version":3,"sources":["webpack:///./src/pages/other/toolMethod.vue?3e5f","webpack:///./src/pages/other/toolMethod.vue","webpack:///src/pages/other/toolMethod.vue","webpack:///./src/pages/other/toolMethod.vue?0eb0","webpack:///./src/pages/other/toolMethod.vue?e79f"],"names":["render","_vm","this","_c","_self","staticClass","attrs","text","staticRenderFns","components","data","methods","component"],"mappings":"yIAAA,W,2CCAA,IAAIA,EAAS,WAAkB,IAAIC,EAAIC,KAAKC,EAAGF,EAAIG,MAAMD,GAAG,OAAOA,EAAG,MAAM,CAACA,EAAG,cAAc,CAACE,YAAY,uBAAuBC,MAAM,CAAC,MAAQL,EAAIM,KAAK,KAAO,aAAaJ,EAAG,MAAM,CAACE,YAAY,kBAAkB,IAElNG,EAAkB,GCMP,GACfC,cAEAC,KAHA,WAIA,OACAH,q+OA0QAI,YCvRmW,I,wBCQ/VC,EAAY,eACd,EACAZ,EACAQ,GACA,EACA,KACA,WACA,MAIa,aAAAI,E","file":"js/chunk-04907ebe.4d260c9b.js","sourcesContent":["export * from \"-!../../../node_modules/mini-css-extract-plugin/dist/loader.js??ref--7-oneOf-1-0!../../../node_modules/css-loader/dist/cjs.js??ref--7-oneOf-1-1!../../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../../node_modules/postcss-loader/src/index.js??ref--7-oneOf-1-2!../../../node_modules/cache-loader/dist/cjs.js??ref--1-0!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./toolMethod.vue?vue&type=style&index=0&id=510300d4&prod&scoped=true&lang=css&\"","var render = function render(){var _vm=this,_c=_vm._self._c;return _c('div',[_c('v-md-editor',{staticClass:\"github-markdown-body\",attrs:{\"value\":_vm.text,\"mode\":\"preview\"}}),_c('div',{staticClass:\"demo-content\"})],1)\n}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","<template lang=\"pug\">\n  div\n    v-md-editor.github-markdown-body(:value=\"text\" mode=\"preview\")\n    div.demo-content\n</template>\n\n<script>\n\nexport default {\n  components: {\n  },\n  data() {\n    return {\n      text: `\n  ### 常用js方法\n  > 0、函数组合。 1、深拷贝。 2、获取url请求的拼接参数。3、获取日期数组。4、生成指定范围的整数(包含两边)。\n  > 5、生成随机颜色。6、格式化日期。7、节流函数。8、下载文件流。9、装饰器-给函数添加新功能。\n  #### 0、函数组合\n  函数式编程的基础，即通过丰富的基础函数，根据业务组合成复杂函数\n  \\`\\`\\`js\n  compose(f,g) {\n    return function(x) {\n      return f(g(x));\n    };\n  }\n  \\`\\`\\`\n  使用方法\n  \\`\\`\\`js\n  let toUpperCase = function(x) {\n    return x.toUpperCase();\n  };\n  let exclaim = function(x) {\n    return x + '!';\n  };\n  let shout = compose(exclaim, toUpperCase);\n  shout(\"send in the clowns\");\n  // => \"SEND IN THE CLOWNS!\"\n  \\`\\`\\`\n  #### 1、深拷贝\n  解决\\`...\\`扩展符一层深拷贝不够 和 JSON.parse(JSON.stringify())深拷贝无法处理函数参数、循环引用的问题。\n  \\`\\`\\`js\n  deepCopy(data, hash = new WeakMap()) {\n    if(typeof data !== 'object' || data === null){\n      throw new TypeError('传入参数不是对象')\n    }\n    // 判断传入的待拷贝对象的引用是否存在于hash中\n    if(hash.has(data)) {\n      return hash.get(data)\n    }\n    let newData = {};\n    const dataKeys = Object.keys(data);\n    dataKeys.forEach(value => {\n      const currentDataValue = data[value];\n      // 基本数据类型的值和函数直接赋值拷贝\n      if (typeof currentDataValue !== \"object\" || currentDataValue === null) {\n        newData[value] = currentDataValue;\n      } else if (Array.isArray(currentDataValue)) {\n        // 实现数组的深拷贝\n        newData[value] = [...currentDataValue];\n      } else if (currentDataValue instanceof Set) {\n        // 实现set数据的深拷贝\n        newData[value] = new Set([...currentDataValue]);\n      } else if (currentDataValue instanceof Map) {\n        // 实现map数据的深拷贝\n        newData[value] = new Map([...currentDataValue]);\n      } else {\n        // 将这个待拷贝对象的引用存于hash中\n        hash.set(data,data)\n        // 普通对象则递归赋值\n        newData[value] = deepCopy(currentDataValue, hash);\n      }\n    });\n    return newData;\n  }\n  \\`\\`\\`\n  使用例子\n  \\`\\`\\`\n  let newObj = deepCopy(obj);\n  \\`\\`\\`\n  #### 2、获取url请求的拼接参数\n  解决获取url参数每次都要重复写逻辑的问题\n  \\`\\`\\`js\n  getQueryStringArgs() {\n    let queryData = '';\n    if (location.search) {\n      queryData = location.search;\n    } else if (location.hash) {\n      queryData = '?' + location.hash.split('?')[1];\n    }\n    let qs = (queryData.length > 0 ? queryData.substring(1) : '');\n    let args = [];\n    for (let item of qs.split('&').map( kv => kv.split('=') )) {\n      let name = decodeURIComponent(item[0]);\n      let value = decodeURIComponent(item[1]);\n      if (name) {\n        args[name] = value;\n      }\n    }\n    return args;\n  }\n  \\`\\`\\`\n  使用例子\n  例如地址是\\`http://localhost:8080/#/other/toolMethod?a=11&b=22\\`\n  \\`\\`\\`js\n  let args = getQueryStringArgs();\n  console.log(args['b'])\n  // 打印 22\n  \\`\\`\\`\n  #### 3、获取日期数组\n  用来解决某些场景需要默认日期值，如最近一周，30天等。\n  默认值是0，即开始结束都是当天。如果给-6就是前一周到当天。\n  \\`\\`\\`\n  getAnyDayFormatDate (num = 0) {\n    let date = new Date();\n    let seperator = '-';\n    let year = date.getFullYear();\n    let month = date.getMonth() + 1;\n    let strDate = date.getDate();\n    if (month >= 1 && month <= 9) {\n      month = '0' + month;\n    }\n    if (strDate >= 0 && strDate <= 9) {\n      strDate = '0' + strDate;\n    }\n    let date2 = new Date(date);\n    date2.setDate(date.getDate() + num);\n    let year2 = date2.getFullYear();\n    let month2 = date2.getMonth() + 1;\n    let strDate2 = date2.getDate();\n    if (month2 >= 1 && month2 <= 9) {\n      month2 = '0' + month2;\n    }\n    if (strDate2 >= 0 && strDate2 <= 9) {\n      strDate2 = '0' + strDate2;\n    }\n\n    let startFormatDate = year2 + seperator + month2 + seperator + strDate2;\n    let endFormatDate = year + seperator + month + seperator + strDate;\n    return [startFormatDate, endFormatDate];\n  }\n  \\`\\`\\`\n  使用例子\n  假如今天是2023-03-24\n  \\`\\`\\`js\n  let data1 = getAnyDayFormatDate() // ['2023-03-24', '2023-03-24']\n  let data2 = getAnyDayFormatDate(-6) // ['2023-03-18', '2023-03-24']\n  \\`\\`\\`\n  #### 4、生成指定范围的整数(包含两边)\n  用来解决一些需要随机数的场景(可以作为一个基础函数，套用在别的方法里)\n  \\`\\`\\`\n  selectFromRange(lowerValue, upperValue) {\n    let choices = upperValue - lowerValue + 1;\n    return Math.floor(Math.random() * choices + lowerValue); // floor舍去小数； random生成 0～1，不包括1的数。\n  },\n  \\`\\`\\`\n  #### 5、生成随机颜色\n  解决一些图表需要自动生成多个不同颜色的问题\n  \\`\\`\\`js\n  // selectFromRange()见上方\n  randomColor() {\n    let color = '#';\n    let point = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 'a', 'b', 'c', 'd', 'e', 'f'];\n    for (let i = 0; i < 6; i++) {\n      let index = this.selectFromRange(0, 16);\n      color = color + point[index];\n    }\n    return color;\n  }\n  \\`\\`\\`\n  #### 6、格式化日期\n  格式化指定日期，默认当天，格式\\`yyyy-MM-dd\\`。其它自定义，如只需要月日就给\\`MM-dd\\`\n  \\`\\`\\`js\n  formatDate(date = new Date(), fmt = 'yyyy-MM-dd') {\n    let o = {\n      \"M+\": date.getMonth() + 1, // 月份\n      \"d+\": date.getDate(), // 日\n      \"h+\": date.getHours(), // 小时\n      \"m+\": date.getMinutes(), // 分\n      \"s+\": date.getSeconds(), // 秒\n      \"q+\": Math.floor((date.getMonth() + 3) / 3), // 季度\n      \"S\": date.getMilliseconds() // 毫秒\n    };\n    if (/(y+)/.test(fmt))\n      fmt = fmt.replace(RegExp.$1, (date.getFullYear() + \"\").substr(4 - RegExp.$1.length));\n    for (let k in o)\n      if (new RegExp(\"(\" + k + \")\").test(fmt)) fmt = fmt.replace(RegExp.$1, (RegExp.$1.length == 1) ? (o[k]) : ((\"00\" + o[k]).substr((\"\" + o[k]).length)));\n    return fmt;\n  }\n  \\`\\`\\`\n  使用例子\n  假如今天是2023-03-24\n  \\`\\`\\`js\n  let date1 = formatDate(); // '2023-03-24'\n  let date2 = formatDate(new Date(), 'MM-dd'); // '03-24'\n  \\`\\`\\`\n  #### 7、节流函数\n  解决部分限频的场景，默认函数调用延迟0.5s\n  \\`\\`\\`js\n  throttle(fn, interval) {\n    let __self = fn; // 需要被延迟执行的函数引用\n    let timer = null; // 定时器\n    let firstTime = true; // 第一次调用标记\n    return function () {\n      let args = arguments; // 被延迟执行的函数的变量\n      let __me = this; // 被延迟执行的函数的this\n      if ( firstTime ) { // 第一次不用延时\n        __self.apply(__me, args); // 执行被延迟执行的函数\n        firstTime = false;\n        return false;\n      }\n      if ( timer ) { // 定时器还在证明在延时期间，不调用原函数\n        return false;\n      }\n      timer = setTimeout( () => {\n        clearTimeout(timer); // 清空本次定时器对象\n        timer = null;\n        __self.apply(__me, args);\n      }, interval || 500); // 默认延迟0.5s\n    };\n  }\n  \\`\\`\\`\n  #### 8、下载文件流\n  解决部分不能window.open()处理的场景\n  \\`\\`\\`js\n  // res接口返回的文件流\n  download(res, type = 'application/pdf;chartset=UTF-8', filename) {\n    // 创建blob对象，解析流数据\n    const blob = new Blob([res], {\n      // 如何后端没返回下载文件类型，则需要手动设置：type: 'application/pdf;chartset=UTF-8' 表示下载文档为pdf，如果是word则设置为msword，excel为excel\n      type: type\n    })\n    const a = document.createElement('a')\n    // 兼容webkix浏览器，处理webkit浏览器中href自动添加blob前缀，默认在浏览器打开而不是下载\n    const URL = window.URL || window.webkitURL\n    // 根据解析后的blob对象创建URL 对象\n    const herf = URL.createObjectURL(blob)\n    // 下载链接\n    a.href = herf\n    // 下载文件名\n    a.download = filename\n    document.body.appendChild(a)\n    a.click()\n    document.body.removeChild(a)\n    // 在内存中移除URL 对象\n    window.URL.revokeObjectURL(herf)\n  }\n  \\`\\`\\`\n  #### 9、装饰器-给函数添加新功能\n  用来解决老代码迭代问题，在不修改原方法前提下，添加功能\n  \\`\\`\\`js\n  functionBefore(originalFn, beforeFn ){\n    let __self = originalFn; // 保存原函数的this\n    return function(){ // 返回一个函数，内容包括新功能和原函数功能\n      beforeFn.apply( originalFn, arguments ); // 执行新函数，保证this不给劫持\n      return __self.apply( originalFn, arguments ); // 执行原函数，并返回原函数的执行结果\n    }\n  },\n  functionAfter(originalFn, afterFn){ // 同理只是把新函数功能的执行顺序放在原函数后面\n    let __self = originalFn;\n    return function(){\n      let ret = __self.apply( originalFn, arguments );\n      afterFn.apply( originalFn, arguments );\n      return ret;\n    }\n  }\n  \\`\\`\\`\n  使用方法\n  \\`\\`\\`js\n  let a = function(){\n    console.log('原函数功能')\n  }\n  a = functionBefore(a,() => {\n    console.log('before-新函数功能')\n  })\n  a(); // 打印：before-新函数功能 原函数功能\n  \\`\\`\\`\n  `,\n    };\n  },\n  methods: {\n  },\n}\n</script>\n\n<style scoped>\n/deep/ .github-markdown-body {\n  padding: 12px 16px 0px;\n}\n.demo-content {\n  border: 1px solid rgba(244,244,244, 0.9);\n  padding: 12px 40px 24px;\n  margin-bottom: 12px;\n}\n.file-text {\n  color: #657cc4;\n}\n</style>\n","import mod from \"-!../../../node_modules/cache-loader/dist/cjs.js??ref--13-0!../../../node_modules/thread-loader/dist/cjs.js!../../../node_modules/babel-loader/lib/index.js!../../../node_modules/cache-loader/dist/cjs.js??ref--1-0!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./toolMethod.vue?vue&type=script&lang=js&\"; export default mod; export * from \"-!../../../node_modules/cache-loader/dist/cjs.js??ref--13-0!../../../node_modules/thread-loader/dist/cjs.js!../../../node_modules/babel-loader/lib/index.js!../../../node_modules/cache-loader/dist/cjs.js??ref--1-0!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./toolMethod.vue?vue&type=script&lang=js&\"","import { render, staticRenderFns } from \"./toolMethod.vue?vue&type=template&id=510300d4&scoped=true&lang=pug&\"\nimport script from \"./toolMethod.vue?vue&type=script&lang=js&\"\nexport * from \"./toolMethod.vue?vue&type=script&lang=js&\"\nimport style0 from \"./toolMethod.vue?vue&type=style&index=0&id=510300d4&prod&scoped=true&lang=css&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  \"510300d4\",\n  null\n  \n)\n\nexport default component.exports"],"sourceRoot":""}