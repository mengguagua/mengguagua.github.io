(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-6e96bf0f"],{"62e7":function(n,e,t){},"91e6":function(n,e,t){"use strict";t.r(e);var a=function(){var n=this,e=n._self._c;return e("div",[e("v-md-editor",{staticClass:"github-markdown-body",attrs:{value:n.text,mode:"preview"}}),e("div",{staticClass:"demo-content"})],1)},r=[],o={components:{},data:function(){return{text:"\n  ### 常用js方法\n  > 0、函数组合。 1、深拷贝。 2、获取url请求的拼接参数。3、获取日期数组。4、生成指定范围的整数(包含两边)。\n  > 5、生成随机颜色。6、格式化日期。7、节流函数。8、下载文件流。9、装饰器-给函数添加新功能。\n  #### 0、函数组合\n  函数式编程的基础，即通过丰富的基础函数，根据业务组合成复杂函数\n  ```js\n  compose(f,g) {\n    return function(x) {\n      return f(g(x));\n    };\n  }\n  ```\n  使用方法\n  ```js\n  let toUpperCase = function(x) {\n    return x.toUpperCase();\n  };\n  let exclaim = function(x) {\n    return x + '!';\n  };\n  let shout = compose(exclaim, toUpperCase);\n  shout(\"send in the clowns\");\n  // => \"SEND IN THE CLOWNS!\"\n  ```\n  #### 1、深拷贝\n  解决`...`扩展符一层深拷贝不够 和 JSON.parse(JSON.stringify())深拷贝无法处理函数参数、循环引用的问题。\n  ```js\n  deepCopy(data, hash = new WeakMap()) {\n    if(typeof data !== 'object' || data === null){\n      throw new TypeError('传入参数不是对象')\n    }\n    // 判断传入的待拷贝对象的引用是否存在于hash中\n    if(hash.has(data)) {\n      return hash.get(data)\n    }\n    let newData = {};\n    const dataKeys = Object.keys(data);\n    dataKeys.forEach(value => {\n      const currentDataValue = data[value];\n      // 基本数据类型的值和函数直接赋值拷贝\n      if (typeof currentDataValue !== \"object\" || currentDataValue === null) {\n        newData[value] = currentDataValue;\n      } else if (Array.isArray(currentDataValue)) {\n        // 实现数组的深拷贝\n        newData[value] = [...currentDataValue];\n      } else if (currentDataValue instanceof Set) {\n        // 实现set数据的深拷贝\n        newData[value] = new Set([...currentDataValue]);\n      } else if (currentDataValue instanceof Map) {\n        // 实现map数据的深拷贝\n        newData[value] = new Map([...currentDataValue]);\n      } else {\n        // 将这个待拷贝对象的引用存于hash中\n        hash.set(data,data)\n        // 普通对象则递归赋值\n        newData[value] = deepCopy(currentDataValue, hash);\n      }\n    });\n    return newData;\n  }\n  ```\n  使用例子\n  ```\n  let newObj = deepCopy(obj);\n  ```\n  #### 2、获取url请求的拼接参数\n  解决获取url参数每次都要重复写逻辑的问题\n  ```js\n  getQueryStringArgs() {\n    let queryData = '';\n    if (location.search) {\n      queryData = location.search;\n    } else if (location.hash) {\n      queryData = '?' + location.hash.split('?')[1];\n    }\n    let qs = (queryData.length > 0 ? queryData.substring(1) : '');\n    let args = [];\n    for (let item of qs.split('&').map( kv => kv.split('=') )) {\n      let name = decodeURIComponent(item[0]);\n      let value = decodeURIComponent(item[1]);\n      if (name) {\n        args[name] = value;\n      }\n    }\n    return args;\n  }\n  ```\n  使用例子\n  例如地址是`http://localhost:8080/#/other/toolMethod?a=11&b=22`\n  ```js\n  let args = getQueryStringArgs();\n  console.log(args['b'])\n  // 打印 22\n  ```\n  #### 3、获取日期数组\n  用来解决某些场景需要默认日期值，如最近一周，30天等。\n  默认值是0，即开始结束都是当天。如果给-6就是前一周到当天。\n  ```\n  getAnyDayFormatDate (num = 0) {\n    let date = new Date();\n    let seperator = '-';\n    let year = date.getFullYear();\n    let month = date.getMonth() + 1;\n    let strDate = date.getDate();\n    if (month >= 1 && month <= 9) {\n      month = '0' + month;\n    }\n    if (strDate >= 0 && strDate <= 9) {\n      strDate = '0' + strDate;\n    }\n    let date2 = new Date(date);\n    date2.setDate(date.getDate() + num);\n    let year2 = date2.getFullYear();\n    let month2 = date2.getMonth() + 1;\n    let strDate2 = date2.getDate();\n    if (month2 >= 1 && month2 <= 9) {\n      month2 = '0' + month2;\n    }\n    if (strDate2 >= 0 && strDate2 <= 9) {\n      strDate2 = '0' + strDate2;\n    }\n\n    let startFormatDate = year2 + seperator + month2 + seperator + strDate2;\n    let endFormatDate = year + seperator + month + seperator + strDate;\n    return [startFormatDate, endFormatDate];\n  }\n  ```\n  使用例子\n  假如今天是2023-03-24\n  ```js\n  let data1 = getAnyDayFormatDate() // ['2023-03-24', '2023-03-24']\n  let data2 = getAnyDayFormatDate(-6) // ['2023-03-18', '2023-03-24']\n  ```\n  #### 4、生成指定范围的整数(包含两边)\n  用来解决一些需要随机数的场景(可以作为一个基础函数，套用在别的方法里)\n  ```\n  selectFromRange(lowerValue, upperValue) {\n    let choices = upperValue - lowerValue + 1;\n    return Math.floor(Math.random() * choices + lowerValue); // floor舍去小数； random生成 0～1，不包括1的数。\n  },\n  ```\n  #### 5、生成随机颜色\n  解决一些图表需要自动生成多个不同颜色的问题\n  ```js\n  // selectFromRange()见上方\n  randomColor() {\n    let color = '#';\n    let point = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 'a', 'b', 'c', 'd', 'e', 'f'];\n    for (let i = 0; i < 6; i++) {\n      let index = this.selectFromRange(0, 16);\n      color = color + point[index];\n    }\n    return color;\n  }\n  ```\n  #### 6、格式化日期\n  格式化指定日期，默认当天，格式`yyyy-MM-dd`。其它自定义，如只需要月日就给`MM-dd`\n  ```js\n  formatDate(date = new Date(), fmt = 'yyyy-MM-dd') {\n    let o = {\n      \"M+\": date.getMonth() + 1, // 月份\n      \"d+\": date.getDate(), // 日\n      \"h+\": date.getHours(), // 小时\n      \"m+\": date.getMinutes(), // 分\n      \"s+\": date.getSeconds(), // 秒\n      \"q+\": Math.floor((date.getMonth() + 3) / 3), // 季度\n      \"S\": date.getMilliseconds() // 毫秒\n    };\n    if (/(y+)/.test(fmt))\n      fmt = fmt.replace(RegExp.$1, (date.getFullYear() + \"\").substr(4 - RegExp.$1.length));\n    for (let k in o)\n      if (new RegExp(\"(\" + k + \")\").test(fmt)) fmt = fmt.replace(RegExp.$1, (RegExp.$1.length == 1) ? (o[k]) : ((\"00\" + o[k]).substr((\"\" + o[k]).length)));\n    return fmt;\n  }\n  ```\n  使用例子\n  假如今天是2023-03-24\n  ```js\n  let date1 = formatDate(); // '2023-03-24'\n  let date2 = formatDate(new Date(), 'MM-dd'); // '03-24'\n  ```\n  #### 7、节流函数\n  解决部分限频的场景，默认函数调用延迟0.5s\n  ```js\n  throttle(fn, interval) {\n    let __self = fn; // 需要被延迟执行的函数引用\n    let timer = null; // 定时器\n    let firstTime = true; // 第一次调用标记\n    return function () {\n      let args = arguments; // 被延迟执行的函数的变量\n      let __me = this; // 被延迟执行的函数的this\n      if ( firstTime ) { // 第一次不用延时\n        __self.apply(__me, args); // 执行被延迟执行的函数\n        firstTime = false;\n        return false;\n      }\n      if ( timer ) { // 定时器还在证明在延时期间，不调用原函数\n        return false;\n      }\n      timer = setTimeout( () => {\n        clearTimeout(timer); // 清空本次定时器对象\n        timer = null;\n        __self.apply(__me, args);\n      }, interval || 500); // 默认延迟0.5s\n    };\n  }\n  ```\n  #### 8、下载文件流\n  解决部分不能window.open()处理的场景\n  ```js\n  // res接口返回的文件流\n  download(res, type = 'application/pdf;chartset=UTF-8', filename) {\n    // 创建blob对象，解析流数据\n    const blob = new Blob([res], {\n      // 如何后端没返回下载文件类型，则需要手动设置：type: 'application/pdf;chartset=UTF-8' 表示下载文档为pdf，如果是word则设置为msword，excel为excel\n      type: type\n    })\n    const a = document.createElement('a')\n    // 兼容webkix浏览器，处理webkit浏览器中href自动添加blob前缀，默认在浏览器打开而不是下载\n    const URL = window.URL || window.webkitURL\n    // 根据解析后的blob对象创建URL 对象\n    const herf = URL.createObjectURL(blob)\n    // 下载链接\n    a.href = herf\n    // 下载文件名\n    a.download = filename\n    document.body.appendChild(a)\n    a.click()\n    document.body.removeChild(a)\n    // 在内存中移除URL 对象\n    window.URL.revokeObjectURL(herf)\n  }\n  ```\n  #### 9、装饰器-给函数添加新功能\n  用来解决老代码迭代问题，在不修改原方法前提下，添加功能\n  ```js\n  functionBefore(originalFn, beforeFn ){\n    let __self = originalFn; // 保存原函数的this\n    return function(){ // 返回一个函数，内容包括新功能和原函数功能\n      beforeFn.apply( originalFn, arguments ); // 执行新函数，保证this不给劫持\n      return __self.apply( originalFn, arguments ); // 执行原函数，并返回原函数的执行结果\n    }\n  },\n  functionAfter(originalFn, afterFn){ // 同理只是把新函数功能的执行顺序放在原函数后面\n    let __self = originalFn;\n    return function(){\n      let ret = __self.apply( originalFn, arguments );\n      afterFn.apply( originalFn, arguments );\n      return ret;\n    }\n  }\n  ```\n  使用方法\n  ```js\n  let a = function(){\n    console.log('原函数功能')\n  }\n  a = functionBefore(a,() => {\n    console.log('before-新函数功能')\n  })\n  a(); // 打印：before-新函数功能 原函数功能\n  ```\n\n  #### 10、计算数组中每个元素出现的次数\n  ```js\n  let totalForArrayElement = (array) => {\n    let itemNum = array.reduce((pre,cur)=>{\n      if(cur in pre){\n        pre[cur]++\n      }else{\n        pre[cur] = 1\n      }\n      return pre\n    },{})\n    return itemNum;\n  }\n  ```\n  使用方法\n  ```js\n  let names = ['Alice', 'Bob', 'Tiff', 'Bruce', 'Alice'];\n  console.log(totalForArrayElement(names));\n  // {Alice: 2, Bob: 1, Tiff: 1, Bruce: 1} // 元素出现次数\n  ```\n\n  #### 11、判断字符串或者数组是否有重复\n  ```js\n  let isUnique = (astr) => {\n    return new Set(astr).size === astr.length\n  };\n  ```\n  使用方法\n  ```js\n  isUnique([1,2,3,{},{}]); // true\n  isUnique([1,2,3,3]); // false\n  isUnique('123'); // true\n  isUnique('1231'); // false\n  ```\n\n  #### 12、创建单例对象（通过闭包）\n  ```js\n  let getSingle = function ( fn ) {\n    let ret;\n    return function () {\n      return ret || ( ret = fn.apply( this, arguments ) );\n    };\n  };\n  ```\n  使用方法\n  ```js\n  let getScript = getSingle(function(){\n    return document.createElement( 'div' );\n  });\n  let script1 = getScript();\n  let script2 = getScript();\n  console.log(script1 === script2) // true\n  ```\n\n  #### 13、记忆函数\n  ```js\n  let memoize = (f) => {\n    let obj = {}; // 通过闭包特效保存之前加载过的数据\n    return function () {\n      let key = JSON.stringify(arguments); // arguments伪数组,如temp(1)断点到这，拿到0:1\n      obj[key] = obj[key] || f.apply(f, arguments); // temp(1)的key就是‘0:1’，temp(2)的key就是‘0:2’\n      return obj[key];\n    }\n  }\n  ```\n  使用方法\n  ```js\n  // 示例函数\n  function demoFun (x) {\n    console.log(x);\n    return x*2021;\n  }\n  let temp = memoize(demoFun);\n  console.log(temp(1));\n  console.log(temp(1));\n  console.log(temp(2));\n  ```\n\n  #### 14、柯里化(复用数据)\n  ```js\n  function curryingCheck(reg) {\n    return function(txt) {\n        return reg.test(txt)\n    }\n  }\n  let hasNumber = curryingCheck(/\\d+/g)\n  let hasLetter = curryingCheck(/[a-z]+/g)\n  ```\n  使用方法\n  ```js\n  hasNumber('test1')      // true\n  hasNumber('testtest')   // false\n  hasLetter('21212')      // false\n  ```\n  "}},methods:{}},l=o,s=(t("ec45"),t("2877")),i=Object(s["a"])(l,a,r,!1,null,"6908690b",null);e["default"]=i.exports},ec45:function(n,e,t){"use strict";t("62e7")}}]);
//# sourceMappingURL=chunk-6e96bf0f.e91211fe.js.map